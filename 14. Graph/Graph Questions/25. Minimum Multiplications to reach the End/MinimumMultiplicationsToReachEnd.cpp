#include <bits/stdc++.h>
using namespace std;

/* ---------------------------------- Solution Class ------------------------------- */
class Solution
{
private:
public:
    /* Question: Given start, end and an array arr of n numbers. At each step, start is multiplied with any number in the array and then mod operation with 100000 is done to get the new start.

    Your task is to find the minimum steps in which end can be achieved starting from start. If it is not possible to reach end, then return -1.*/

    /*
    Time Complexity : O(100000 * N) 
    Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied.

    Space Complexity :  O(100000 * N) 
    Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied. 100000 * N is the max possible queue size. The space complexity of the dist array is constant.
    */
    int minimumMultiplications(vector<int> &arr, int start, int end)
    {
        // Create a queue for storing the numbers as a result of multiplication
        // of the numbers in the array and the start number.

        // Queue is of type {steps, result}, result  = start * arr[i].
        queue<pair<int, int>> q;

        // Push the 'start' into the queue with the steps 0.
        q.push({0, start});

        // Create a dist array to store the no. of multiplications to reach
        // a particular number from the start number.
        vector<int> distance(1e5, INT_MAX);
        distance[start] = 0;

        // Mod value.
        int mod = 1e5;

        // Traverse the queue.
        while (!q.empty())
        {
            // Take out the front element of the queue.
            auto frontNode = q.front();

            // Pop the front element of the queue.
            q.pop();

            // Take out the node and steps to reach that node from the frontNode.
            int steps = frontNode.first;
            int node = frontNode.second;

            // Traverse the array and multiple the node with each of the numbers in the array.
            // repeate this process until we get the end number.
            for (auto num : arr)
            {
                // storing the result of multiplication.
                int result = (node * num) % mod;

                // If the number of steps to reach this 'result' is less than previous steps, then we update the distance array.
                if (steps + 1 < distance[result])
                {
                    distance[result] = steps + 1;

                    // if the result == end, it means we reached the end number.
                    // so return the steps.
                    if (result == end)
                    {
                        return steps + 1;
                    }

                    // push this pair into the queue.
                    q.push({steps + 1, result});
                }
            }
        }

        // if the above loop does not return the answer, it means the end is unreachable so return -1.
        return -1;
    }
};

int main(void)
{
    int start = 3, end = 30;
    vector<int> arr = {2, 5, 7};

    // Solution.
    Solution S;
    cout << S.minimumMultiplications(arr, start, end);
}